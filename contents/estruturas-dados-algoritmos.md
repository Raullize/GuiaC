<img width=100% src="https://capsule-render.vercel.app/api?type=waving&color=A8B9CC&height=120&section=header"/>

# üìä Estruturas de Dados e Algoritmos em C

Neste guia, vamos explorar as principais estruturas de dados e algoritmos de ordena√ß√£o e busca em C.

## üß† O que s√£o Estruturas de Dados?

Estruturas de dados s√£o formas de organizar, gerenciar e armazenar dados de maneira eficiente para que possam ser utilizados de forma apropriada durante a execu√ß√£o de um programa. Elas s√£o fundamentais para a constru√ß√£o de algoritmos eficientes e para a resolu√ß√£o de problemas complexos em programa√ß√£o.

### Por que estudar Estruturas de Dados?
- Permitem manipular grandes volumes de dados de forma eficiente
- Facilitam a implementa√ß√£o de algoritmos de busca, ordena√ß√£o e processamento
- S√£o a base para o desenvolvimento de sistemas, bancos de dados, compiladores, jogos, intelig√™ncia artificial, etc.

### Tipos de Estruturas de Dados
As principais estruturas de dados estudadas em C s√£o:

- **Vetores (Arrays):** Estrutura sequencial de tamanho fixo, ideal para armazenar elementos do mesmo tipo.
- **Listas:** Estruturas din√¢micas que permitem inser√ß√£o e remo√ß√£o de elementos em qualquer posi√ß√£o. Podem ser listas simplesmente encadeadas, duplamente encadeadas, circulares, etc.
- **Pilhas (Stack):** Estrutura do tipo LIFO (Last In, First Out), onde o √∫ltimo elemento inserido √© o primeiro a ser removido. Muito usada em algoritmos de recurs√£o, controle de chamadas de fun√ß√µes, desfazer/refazer opera√ß√µes, etc.
- **Filas (Queue):** Estrutura do tipo FIFO (First In, First Out), onde o primeiro elemento inserido √© o primeiro a ser removido. Utilizada em sistemas de impress√£o, filas de atendimento, buffers, etc.
- **√Årvores:** Estruturas hier√°rquicas, como √°rvores bin√°rias, AVL, B-trees, muito usadas em bancos de dados, sistemas de arquivos e algoritmos de busca.
- **Tabelas Hash:** Estruturas que permitem acesso r√°pido a dados por meio de fun√ß√µes de dispers√£o (hash), ideais para buscas r√°pidas e armazenamento de grandes volumes de dados.
- **Grafos:** Estruturas que representam rela√ß√µes entre objetos, muito usadas em redes, mapas, rotas, redes sociais, etc.

### Como escolher a estrutura de dados?
A escolha depende do problema a ser resolvido, do tipo de opera√ß√£o mais frequente (busca, inser√ß√£o, remo√ß√£o, ordena√ß√£o) e das restri√ß√µes de tempo e mem√≥ria.

### Aplica√ß√µes pr√°ticas
- **Pilhas:** Controle de chamadas de fun√ß√µes, algoritmos de backtracking, editores de texto (desfazer/refazer)
- **Filas:** Impressoras, sistemas de atendimento, buffers de comunica√ß√£o
- **Listas:** Manipula√ß√£o din√¢mica de dados, implementa√ß√£o de outras estruturas
- **√Årvores:** √çndices de banco de dados, compress√£o de dados, intelig√™ncia artificial
- **Tabelas Hash:** Dicion√°rios, caches, sistemas de autentica√ß√£o
- **Grafos:** Mapas, redes de computadores, algoritmos de navega√ß√£o

---

## üèóÔ∏è Estruturas de Dados

### Pilhas (Stack)

**O que √©?**

Uma pilha √© uma estrutura de dados linear do tipo LIFO (Last In, First Out), ou seja, o √∫ltimo elemento inserido √© o primeiro a ser removido. Imagine uma pilha de pratos: voc√™ s√≥ pode retirar o prato que est√° no topo.

**Principais opera√ß√µes:**
- `empilhar` (push): adiciona um elemento ao topo
- `desempilhar` (pop): remove o elemento do topo
- `topo` (peek): consulta o elemento do topo sem remov√™-lo

**Aplica√ß√µes pr√°ticas:**
- Controle de chamadas de fun√ß√µes (pilha de execu√ß√£o)
- Algoritmos de recurs√£o
- Desfazer/refazer em editores de texto
- Convers√£o de express√µes (infixa, p√≥s-fixa)
- Algoritmos de backtracking (ex: resolver labirintos)

**Vantagens:**
- Simples de implementar
- √ìtima para problemas que exigem revers√£o de opera√ß√µes

**Desvantagens:**
- Acesso restrito (apenas topo)
- N√£o √© eficiente para busca de elementos arbitr√°rios

**Curiosidade:**
- A pilha √© usada internamente pelo processador para armazenar o contexto de fun√ß√µes e vari√°veis locais.

```c
#define MAX 100

typedef struct {
    int dados[MAX];
    int topo;
} Pilha;

void inicializarPilha(Pilha *p) {
    p->topo = -1;
}

void empilhar(Pilha *p, int valor) {
    if (p->topo < MAX - 1) {
        p->topo++;
        p->dados[p->topo] = valor;
    }
}

int desempilhar(Pilha *p) {
    if (p->topo >= 0) {
        int valor = p->dados[p->topo];
        p->topo--;
        return valor;
    }
    return -1;
}
```

### Filas (Queue)

**O que √©?**

Uma fila √© uma estrutura de dados linear do tipo FIFO (First In, First Out), ou seja, o primeiro elemento inserido √© o primeiro a ser removido. Imagine uma fila de pessoas no banco: quem chega primeiro √© atendido primeiro.

**Principais opera√ß√µes:**
- `enfileirar` (enqueue): adiciona um elemento ao final
- `desenfileirar` (dequeue): remove o elemento do in√≠cio
- `frente` (front): consulta o elemento do in√≠cio sem remov√™-lo

**Aplica√ß√µes pr√°ticas:**
- Filas de impress√£o
- Sistemas de atendimento
- Buffers de comunica√ß√£o (ex: streaming)
- Simula√ß√£o de processos (ex: filas de supermercado)

**Vantagens:**
- Simples de implementar
- Garante ordem de processamento

**Desvantagens:**
- Acesso restrito (apenas in√≠cio e fim)
- N√£o √© eficiente para busca de elementos arbitr√°rios

**Curiosidade:**
- Existem varia√ß√µes como fila circular, fila de prioridade e deque (fila dupla).

```c
#define MAX 100

typedef struct {
    int dados[MAX];
    int inicio;
    int fim;
    int tamanho;
} Fila;

void inicializarFila(Fila *f) {
    f->inicio = 0;
    f->fim = -1;
    f->tamanho = 0;
}

void enfileirar(Fila *f, int valor) {
    if (f->tamanho < MAX) {
        f->fim = (f->fim + 1) % MAX;
        f->dados[f->fim] = valor;
        f->tamanho++;
    }
}

int desenfileirar(Fila *f) {
    if (f->tamanho > 0) {
        int valor = f->dados[f->inicio];
        f->inicio = (f->inicio + 1) % MAX;
        f->tamanho--;
        return valor;
    }
    return -1;
}
```

## üîç Algoritmos de Busca

### Busca Linear

**O que √©?**

A busca linear (ou sequencial) percorre todos os elementos de um vetor at√© encontrar o valor desejado ou chegar ao final. √â simples, mas pode ser lenta para grandes volumes de dados.

**Quando usar?**
- Vetores pequenos
- Dados n√£o ordenados

**Vantagens:**
- Simplicidade
- N√£o exige ordena√ß√£o

**Desvantagens:**
- Ineficiente para grandes volumes (complexidade O(n))

### Busca Bin√°ria

**O que √©?**

A busca bin√°ria s√≥ pode ser usada em vetores ordenados. Ela divide o vetor ao meio a cada passo, reduzindo drasticamente o n√∫mero de compara√ß√µes.

**Quando usar?**
- Vetores grandes
- Dados ordenados

**Vantagens:**
- Muito eficiente (complexidade O(log n))

**Desvantagens:**
- S√≥ funciona em dados ordenados
- Mais complexa de implementar

**Curiosidade:**
- A busca bin√°ria √© a base de algoritmos de busca em bancos de dados e sistemas de arquivos.

```c
int buscaLinear(int vetor[], int tamanho, int valor) {
    for (int i = 0; i < tamanho; i++) {
        if (vetor[i] == valor) {
            return i;
        }
    }
    return -1;
}

int buscaBinaria(int vetor[], int inicio, int fim, int valor) {
    if (fim >= inicio) {
        int meio = inicio + (fim - inicio) / 2;
        
        if (vetor[meio] == valor)
            return meio;
            
        if (vetor[meio] > valor)
            return buscaBinaria(vetor, inicio, meio - 1, valor);
            
        return buscaBinaria(vetor, meio + 1, fim, valor);
    }
    return -1;
}
```

## üìä Algoritmos de Ordena√ß√£o

Ordenar dados √© uma tarefa fundamental em programa√ß√£o. Existem v√°rios algoritmos, cada um com caracter√≠sticas pr√≥prias.

### Bubble Sort

**Como funciona?**
Compara pares de elementos adjacentes e os troca de lugar se estiverem fora de ordem. Repete o processo at√© que o vetor esteja ordenado.

**Vantagens:**
- F√°cil de entender e implementar

**Desvantagens:**
- Muito ineficiente para grandes volumes (O(n¬≤))

**Quando usar?**
- Pequenos conjuntos de dados
- Situa√ß√µes did√°ticas

```c
void bubbleSort(int vetor[], int tamanho) {
    for (int i = 0; i < tamanho - 1; i++) {
        for (int j = 0; j < tamanho - i - 1; j++) {
            if (vetor[j] > vetor[j + 1]) {
                int temp = vetor[j];
                vetor[j] = vetor[j + 1];
                vetor[j + 1] = temp;
            }
        }
    }
}
```

### Selection Sort

**Como funciona?**
Procura o menor elemento e o coloca na primeira posi√ß√£o, depois o segundo menor na segunda posi√ß√£o, e assim por diante.

**Vantagens:**
- Simples
- Poucas trocas

**Desvantagens:**
- Ineficiente para grandes volumes (O(n¬≤))

```c
void selectionSort(int vetor[], int tamanho) {
    for (int i = 0; i < tamanho - 1; i++) {
        int min_idx = i;
        for (int j = i + 1; j < tamanho; j++) {
            if (vetor[j] < vetor[min_idx])
                min_idx = j;
        }
        int temp = vetor[min_idx];
        vetor[min_idx] = vetor[i];
        vetor[i] = temp;
    }
}
```

### Insertion Sort

**Como funciona?**
Constr√≥i o vetor ordenado um elemento por vez, inserindo cada novo elemento na posi√ß√£o correta.

**Vantagens:**
- Bom para vetores pequenos ou quase ordenados

**Desvantagens:**
- Ineficiente para grandes volumes (O(n¬≤))

```c
void insertionSort(int vetor[], int tamanho) {
    for (int i = 1; i < tamanho; i++) {
        int chave = vetor[i];
        int j = i - 1;
        
        while (j >= 0 && vetor[j] > chave) {
            vetor[j + 1] = vetor[j];
            j--;
        }
        vetor[j + 1] = chave;
    }
}
```

### Quick Sort

**Como funciona?**
Escolhe um piv√¥, separa os elementos menores √† esquerda e maiores √† direita, e aplica o processo recursivamente.

**Vantagens:**
- Muito eficiente na pr√°tica (O(n log n) em m√©dia)

**Desvantagens:**
- Pior caso O(n¬≤) (mas raro)
- N√£o √© est√°vel

```c
int particionar(int vetor[], int baixo, int alto) {
    int pivo = vetor[alto];
    int i = (baixo - 1);
    
    for (int j = baixo; j <= alto - 1; j++) {
        if (vetor[j] < pivo) {
            i++;
            int temp = vetor[i];
            vetor[i] = vetor[j];
            vetor[j] = temp;
        }
    }
    int temp = vetor[i + 1];
    vetor[i + 1] = vetor[alto];
    vetor[alto] = temp;
    return (i + 1);
}

void quickSort(int vetor[], int baixo, int alto) {
    if (baixo < alto) {
        int pi = particionar(vetor, baixo, alto);
        quickSort(vetor, baixo, pi - 1);
        quickSort(vetor, pi + 1, alto);
    }
}
```

### Shell Sort

**Como funciona?**
Generaliza o insertion sort, permitindo compara√ß√µes e trocas entre elementos distantes. Reduz o intervalo gradualmente at√© ordenar todo o vetor.

**Vantagens:**
- Mais eficiente que insertion/bubble/selection para vetores m√©dios

**Desvantagens:**
- Complexidade depende da sequ√™ncia de gaps

```c
void shellSort(int vetor[], int tamanho) {
    for (int gap = tamanho/2; gap > 0; gap /= 2) {
        for (int i = gap; i < tamanho; i++) {
            int temp = vetor[i];
            int j;
            for (j = i; j >= gap && vetor[j - gap] > temp; j -= gap) {
                vetor[j] = vetor[j - gap];
            }
            vetor[j] = temp;
        }
    }
}
```

### Merge Sort

**Como funciona?**
Divide o vetor em duas partes, ordena cada uma recursivamente e depois intercala (merge) as duas partes ordenadas.

**Vantagens:**
- Sempre O(n log n)
- Est√°vel

**Desvantagens:**
- Usa mem√≥ria extra

**Curiosidade:**
- Merge sort √© muito usado em bancos de dados e sistemas que precisam ordenar grandes volumes de dados em disco.

```c
void merge(int vetor[], int esquerda, int meio, int direita) {
    int i, j, k;
    int n1 = meio - esquerda + 1;
    int n2 = direita - meio;
    
    int L[n1], R[n2];
    
    for (i = 0; i < n1; i++)
        L[i] = vetor[esquerda + i];
    for (j = 0; j < n2; j++)
        R[j] = vetor[meio + 1 + j];
        
    i = 0;
    j = 0;
    k = esquerda;
    
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            vetor[k] = L[i];
            i++;
        } else {
            vetor[k] = R[j];
            j++;
        }
        k++;
    }
    
    while (i < n1) {
        vetor[k] = L[i];
        i++;
        k++;
    }
    
    while (j < n2) {
        vetor[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(int vetor[], int esquerda, int direita) {
    if (esquerda < direita) {
        int meio = esquerda + (direita - esquerda) / 2;
        mergeSort(vetor, esquerda, meio);
        mergeSort(vetor, meio + 1, direita);
        merge(vetor, esquerda, meio, direita);
    }
}
```

## üìå Complexidade dos Algoritmos

### Busca
- Busca Linear: O(n)
- Busca Bin√°ria: O(log n)

### Ordena√ß√£o
- Bubble Sort: O(n¬≤)
- Selection Sort: O(n¬≤)
- Insertion Sort: O(n¬≤)
- Quick Sort: O(n log n) m√©dio, O(n¬≤) pior caso
- Shell Sort: O(n log n)
- Merge Sort: O(n log n)

## üéØ Exemplos Pr√°ticos

### Exemplo 1: Sistema de Gerenciamento de Tarefas
```c
typedef struct {
    char descricao[100];
    int prioridade;
    int concluida;
} Tarefa;

typedef struct {
    Tarefa tarefas[100];
    int quantidade;
} ListaTarefas;

void adicionarTarefa(ListaTarefas *lista, Tarefa tarefa) {
    if (lista->quantidade < 100) {
        lista->tarefas[lista->quantidade] = tarefa;
        lista->quantidade++;
    }
}

void ordenarPorPrioridade(ListaTarefas *lista) {
    for (int i = 0; i < lista->quantidade - 1; i++) {
        for (int j = 0; j < lista->quantidade - i - 1; j++) {
            if (lista->tarefas[j].prioridade < lista->tarefas[j + 1].prioridade) {
                Tarefa temp = lista->tarefas[j];
                lista->tarefas[j] = lista->tarefas[j + 1];
                lista->tarefas[j + 1] = temp;
            }
        }
    }
}
```

## ‚ö†Ô∏è Considera√ß√µes Importantes

1. Escolha o algoritmo adequado para cada situa√ß√£o
2. Considere a complexidade do algoritmo
3. Teste com diferentes tamanhos de dados
4. Otimize quando necess√°rio
5. Documente o c√≥digo

---

[üîô Voltar ao √≠ndice principal](../README.md)

<img width=100% src="https://capsule-render.vercel.app/api?type=waving&color=A8B9CC&height=120&section=footer"/> 