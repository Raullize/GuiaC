<img width=100% src="https://capsule-render.vercel.app/api?type=waving&color=A8B9CC&height=120&section=header"/>

# üîÅ Fun√ß√µes Recursivas

## üìã Compreendendo a Recurs√£o em C

Recurs√£o √© uma t√©cnica poderosa onde uma fun√ß√£o chama a si mesma para resolver um problema. Essa abordagem permite solucionar problemas complexos dividindo-os em casos mais simples, seguindo o paradigma "dividir para conquistar".

### üß© Conceitos Fundamentais da Recurs√£o

A recurs√£o √© baseada em dois componentes essenciais:

1. **Caso Base**: A condi√ß√£o de parada que encerra as chamadas recursivas
2. **Caso Recursivo**: A parte que divide o problema e faz a chamada recursiva

Uma fun√ß√£o recursiva bem estruturada sempre deve ter pelo menos um caso base que possa ser resolvido diretamente, sem recurs√£o adicional.

#### 1Ô∏è‚É£ Anatomia de uma Fun√ß√£o Recursiva

```c
tipo_retorno funcao_recursiva(parametros) {
    // Caso base - condi√ß√£o de parada
    if (condicao_de_parada) {
        return valor_caso_base;
    }
    
    // Caso recursivo 
    // Processa e reduz o problema
    // Chama a si mesma com entrada reduzida
    return funcao_recursiva(entrada_reduzida);
}
```

### ‚≠ê Exemplos Cl√°ssicos de Recurs√£o

#### 1Ô∏è‚É£ Fatorial

O fatorial de um n√∫mero n (representado como n!) √© o produto de todos os inteiros positivos menores ou iguais a n.

```c
#include <stdio.h>

// Fun√ß√£o recursiva para calcular o fatorial
unsigned long fatorial(unsigned int n) {
    // Caso base
    if (n == 0 || n == 1) {
        return 1;
    }
    
    // Caso recursivo
    return n * fatorial(n - 1);
}

int main() {
    unsigned int numero = 5;
    printf("Fatorial de %u = %lu\n", numero, fatorial(numero));
    return 0;
}
```

**Explica√ß√£o da Recurs√£o**:
- Caso base: Se n = 0 ou n = 1, retorna 1
- Caso recursivo: Para n > 1, calcula n * fatorial(n-1)

**Execu√ß√£o para fatorial(5)**:
```
fatorial(5) = 5 * fatorial(4)
             = 5 * (4 * fatorial(3))
             = 5 * (4 * (3 * fatorial(2)))
             = 5 * (4 * (3 * (2 * fatorial(1))))
             = 5 * (4 * (3 * (2 * 1)))
             = 5 * (4 * (3 * 2))
             = 5 * (4 * 6)
             = 5 * 24
             = 120
```

#### 2Ô∏è‚É£ Fibonacci

A sequ√™ncia de Fibonacci √© uma s√©rie onde cada n√∫mero √© a soma dos dois anteriores. Come√ßa com 0 e 1, e continua: 0, 1, 1, 2, 3, 5, 8, 13, ...

```c
#include <stdio.h>

// Fun√ß√£o recursiva para calcular o n-√©simo n√∫mero de Fibonacci
int fibonacci(int n) {
    // Casos base
    if (n <= 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    
    // Caso recursivo
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    int n = 7;
    printf("O %d-√©simo n√∫mero de Fibonacci √©: %d\n", n, fibonacci(n));
    
    printf("Primeiros 10 n√∫meros da sequ√™ncia de Fibonacci:\n");
    for (int i = 0; i < 10; i++) {
        printf("%d ", fibonacci(i));
    }
    printf("\n");
    
    return 0;
}
```

**Explica√ß√£o da Recurs√£o**:
- Casos base: Se n ‚â§ 0, retorna 0; Se n = 1, retorna 1
- Caso recursivo: Para n > 1, calcula fibonacci(n-1) + fibonacci(n-2)

**√Årvore recursiva para fibonacci(5)**:
```
                      fib(5)
                    /        \
               fib(4)         fib(3)
              /      \        /     \
         fib(3)      fib(2)  fib(2)  fib(1)
        /     \      /    \   /    \
   fib(2)   fib(1) fib(1) fib(0) fib(1) fib(0)
  /     \
fib(1) fib(0)
```

#### 3Ô∏è‚É£ M√°ximo Divisor Comum (MDC)

O algoritmo de Euclides para encontrar o MDC pode ser implementado de forma recursiva.

```c
#include <stdio.h>

// Fun√ß√£o recursiva para calcular o MDC usando o algoritmo de Euclides
int mdc(int a, int b) {
    // Caso base
    if (b == 0) {
        return a;
    }
    
    // Caso recursivo
    return mdc(b, a % b);
}

int main() {
    int num1 = 48, num2 = 18;
    printf("MDC de %d e %d √©: %d\n", num1, num2, mdc(num1, num2));
    return 0;
}
```

**Explica√ß√£o da Recurs√£o**:
- Caso base: Se b = 0, retorna a
- Caso recursivo: Calcula mdc(b, a % b)

**Execu√ß√£o para mdc(48, 18)**:
```
mdc(48, 18) = mdc(18, 48 % 18) = mdc(18, 12)
            = mdc(12, 18 % 12) = mdc(12, 6)
            = mdc(6, 12 % 6)   = mdc(6, 0)
            = 6 (caso base: b = 0, retorna a)
```

### üîÑ Tipos de Recurs√£o

#### 1Ô∏è‚É£ Recurs√£o Direta

A fun√ß√£o chama a si mesma diretamente, como nos exemplos anteriores.

#### 2Ô∏è‚É£ Recurs√£o Indireta

Uma fun√ß√£o A chama uma fun√ß√£o B, que por sua vez chama a fun√ß√£o A, formando um ciclo.

```c
#include <stdio.h>

// Declara√ß√µes antecipadas
int eh_par(int n);
int eh_impar(int n);

// Fun√ß√£o que verifica se um n√∫mero √© par usando recurs√£o indireta
int eh_par(int n) {
    if (n == 0) {
        return 1;  // Zero √© par
    }
    return eh_impar(n - 1);
}

// Fun√ß√£o que verifica se um n√∫mero √© √≠mpar usando recurs√£o indireta
int eh_impar(int n) {
    if (n == 0) {
        return 0;  // Zero n√£o √© √≠mpar
    }
    return eh_par(n - 1);
}

int main() {
    int num = 7;
    if (eh_par(num)) {
        printf("%d √© par\n", num);
    } else {
        printf("%d √© √≠mpar\n", num);
    }
    return 0;
}
```

#### 3Ô∏è‚É£ Recurs√£o em Cauda

Ocorre quando a chamada recursiva √© a √∫ltima opera√ß√£o na fun√ß√£o. Esta forma pode ser otimizada pelo compilador.

```c
#include <stdio.h>

// Vers√£o n√£o otimizada para calcular fatorial
unsigned long fatorial_normal(unsigned int n) {
    if (n == 0 || n == 1) {
        return 1;
    }
    return n * fatorial_normal(n - 1);  // N√£o √© recurs√£o de cauda
}

// Vers√£o com recurs√£o em cauda
unsigned long fatorial_cauda(unsigned int n, unsigned long acumulador) {
    if (n == 0 || n == 1) {
        return acumulador;
    }
    return fatorial_cauda(n - 1, n * acumulador);  // Recurs√£o em cauda
}

// Fun√ß√£o wrapper para simplificar o uso
unsigned long fatorial(unsigned int n) {
    return fatorial_cauda(n, 1);
}

int main() {
    unsigned int numero = 5;
    printf("Fatorial de %u = %lu\n", numero, fatorial(numero));
    return 0;
}
```

### üßÆ Aplica√ß√µes Pr√°ticas da Recurs√£o

#### 1Ô∏è‚É£ Torres de Han√≥i

O problema das Torres de Han√≥i √© um quebra-cabe√ßa cl√°ssico que pode ser resolvido elegantemente com recurs√£o.

```c
#include <stdio.h>

void hanoi(int n, char origem, char auxiliar, char destino) {
    if (n == 1) {
        printf("Mova o disco 1 de %c para %c\n", origem, destino);
        return;
    }
    
    hanoi(n - 1, origem, destino, auxiliar);
    printf("Mova o disco %d de %c para %c\n", n, origem, destino);
    hanoi(n - 1, auxiliar, origem, destino);
}

int main() {
    int n = 3;  // N√∫mero de discos
    printf("Solu√ß√£o para Torres de Han√≥i com %d discos:\n", n);
    hanoi(n, 'A', 'B', 'C');
    return 0;
}
```

#### 2Ô∏è‚É£ Busca Bin√°ria Recursiva

Implementa√ß√£o recursiva do algoritmo de busca bin√°ria.

```c
#include <stdio.h>

// Fun√ß√£o recursiva para busca bin√°ria
int busca_binaria(int arr[], int esquerda, int direita, int alvo) {
    // Caso base: elemento n√£o encontrado
    if (esquerda > direita) {
        return -1;
    }
    
    int meio = esquerda + (direita - esquerda) / 2;
    
    // Caso base: elemento encontrado
    if (arr[meio] == alvo) {
        return meio;
    }
    
    // Caso recursivo
    if (arr[meio] > alvo) {
        return busca_binaria(arr, esquerda, meio - 1, alvo);
    } else {
        return busca_binaria(arr, meio + 1, direita, alvo);
    }
}

int main() {
    int arr[] = {2, 5, 8, 12, 16, 23, 38, 45, 56, 72, 91};
    int n = sizeof(arr) / sizeof(arr[0]);
    int alvo = 23;
    
    int resultado = busca_binaria(arr, 0, n - 1, alvo);
    
    if (resultado == -1) {
        printf("Elemento %d n√£o encontrado no array\n", alvo);
    } else {
        printf("Elemento %d encontrado na posi√ß√£o %d\n", alvo, resultado);
    }
    
    return 0;
}
```

#### 3Ô∏è‚É£ Percurso em Estruturas de Dados

Recurs√£o √© frequentemente usada para percorrer estruturas de dados complexas, como √°rvores.

```c
#include <stdio.h>
#include <stdlib.h>

// Defini√ß√£o de uma estrutura de n√≥ de √°rvore bin√°ria
typedef struct No {
    int valor;
    struct No* esquerda;
    struct No* direita;
} No;

// Fun√ß√£o para criar um novo n√≥
No* criar_no(int valor) {
    No* novo = (No*)malloc(sizeof(No));
    if (novo) {
        novo->valor = valor;
        novo->esquerda = NULL;
        novo->direita = NULL;
    }
    return novo;
}

// Percurso em ordem (in-order traversal)
void percurso_em_ordem(No* raiz) {
    if (raiz != NULL) {
        percurso_em_ordem(raiz->esquerda);  // Visita sub√°rvore esquerda
        printf("%d ", raiz->valor);         // Visita raiz
        percurso_em_ordem(raiz->direita);   // Visita sub√°rvore direita
    }
}

// Percurso pr√©-ordem (pre-order traversal)
void percurso_pre_ordem(No* raiz) {
    if (raiz != NULL) {
        printf("%d ", raiz->valor);         // Visita raiz
        percurso_pre_ordem(raiz->esquerda); // Visita sub√°rvore esquerda
        percurso_pre_ordem(raiz->direita);  // Visita sub√°rvore direita
    }
}

// Percurso p√≥s-ordem (post-order traversal)
void percurso_pos_ordem(No* raiz) {
    if (raiz != NULL) {
        percurso_pos_ordem(raiz->esquerda); // Visita sub√°rvore esquerda
        percurso_pos_ordem(raiz->direita);  // Visita sub√°rvore direita
        printf("%d ", raiz->valor);         // Visita raiz
    }
}

// Fun√ß√£o para liberar a mem√≥ria da √°rvore
void liberar_arvore(No* raiz) {
    if (raiz != NULL) {
        liberar_arvore(raiz->esquerda);
        liberar_arvore(raiz->direita);
        free(raiz);
    }
}

int main() {
    // Criando uma √°rvore de exemplo
    No* raiz = criar_no(10);
    raiz->esquerda = criar_no(5);
    raiz->direita = criar_no(15);
    raiz->esquerda->esquerda = criar_no(3);
    raiz->esquerda->direita = criar_no(7);
    raiz->direita->esquerda = criar_no(12);
    raiz->direita->direita = criar_no(18);
    
    printf("Percurso em ordem: ");
    percurso_em_ordem(raiz);
    printf("\n");
    
    printf("Percurso pr√©-ordem: ");
    percurso_pre_ordem(raiz);
    printf("\n");
    
    printf("Percurso p√≥s-ordem: ");
    percurso_pos_ordem(raiz);
    printf("\n");
    
    // Libera mem√≥ria
    liberar_arvore(raiz);
    
    return 0;
}
```

### ‚ö†Ô∏è Limita√ß√µes e Desafios da Recurs√£o

#### 1Ô∏è‚É£ Consumo de Pilha

Cada chamada recursiva consome espa√ßo na pilha (stack) de execu√ß√£o, o que pode levar a um estouro de pilha (stack overflow) para entradas muito grandes.

```c
#include <stdio.h>

// Fun√ß√£o propensa a estouro de pilha para entradas grandes
int fibonacci_ineficiente(int n) {
    if (n <= 1) return n;
    return fibonacci_ineficiente(n - 1) + fibonacci_ineficiente(n - 2);
}

// Teste com valor grande
int main() {
    int n = 45;  // Valor relativamente grande
    printf("Calculando fibonacci(%d)...\n", n);
    printf("Resultado: %d\n", fibonacci_ineficiente(n));  // Muito lento!
    return 0;
}
```

#### 2Ô∏è‚É£ Inefici√™ncia em Certos Casos

Em fun√ß√µes como `fibonacci_ineficiente` acima, h√° muitos c√°lculos redundantes. Uma solu√ß√£o iterativa ou com memoiza√ß√£o seria muito mais eficiente.

#### 3Ô∏è‚É£ Memoiza√ß√£o para Otimizar a Recurs√£o

A memoiza√ß√£o √© uma t√©cnica para armazenar resultados de chamadas anteriores, evitando rec√°lculos.

```c
#include <stdio.h>
#include <stdlib.h>

// Fibonacci com memoiza√ß√£o
int fibonacci_memo(int n, int* memo) {
    if (memo[n] != -1) {
        return memo[n];  // Retorna resultado j√° calculado
    }
    
    if (n <= 1) {
        memo[n] = n;
    } else {
        memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo);
    }
    
    return memo[n];
}

int fibonacci(int n) {
    if (n < 0) return -1;  // Erro para entrada negativa
    
    // Inicializa array de memoiza√ß√£o
    int* memo = (int*)malloc((n + 1) * sizeof(int));
    if (!memo) return -1;  // Erro de aloca√ß√£o
    
    for (int i = 0; i <= n; i++) {
        memo[i] = -1;  // -1 indica valor n√£o calculado
    }
    
    int resultado = fibonacci_memo(n, memo);
    free(memo);
    return resultado;
}

int main() {
    int n = 45;  // Agora √© r√°pido mesmo para valores grandes
    printf("Fibonacci(%d) = %d\n", n, fibonacci(n));
    return 0;
}
```

### üîÑ Convers√£o de Recurs√£o para Itera√ß√£o

Muitas fun√ß√µes recursivas podem ser reescritas de forma iterativa, o que geralmente √© mais eficiente.

#### 1Ô∏è‚É£ Fatorial Iterativo

```c
#include <stdio.h>

unsigned long fatorial_iterativo(unsigned int n) {
    unsigned long resultado = 1;
    
    for (unsigned int i = 2; i <= n; i++) {
        resultado *= i;
    }
    
    return resultado;
}

int main() {
    unsigned int numero = 5;
    printf("Fatorial de %u = %lu\n", numero, fatorial_iterativo(numero));
    return 0;
}
```

#### 2Ô∏è‚É£ Fibonacci Iterativo

```c
#include <stdio.h>

int fibonacci_iterativo(int n) {
    if (n <= 0) return 0;
    if (n == 1) return 1;
    
    int fib_prev = 0;
    int fib_curr = 1;
    int fib_next;
    
    for (int i = 2; i <= n; i++) {
        fib_next = fib_prev + fib_curr;
        fib_prev = fib_curr;
        fib_curr = fib_next;
    }
    
    return fib_curr;
}

int main() {
    int n = 10;
    printf("Primeiros %d n√∫meros da sequ√™ncia de Fibonacci:\n", n);
    for (int i = 0; i < n; i++) {
        printf("%d ", fibonacci_iterativo(i));
    }
    printf("\n");
    return 0;
}
```

### üß† Boas Pr√°ticas para Recurs√£o

1. **Sempre tenha um caso base claro** para evitar recurs√£o infinita
2. **Verifique os limites de entrada** para prevenir comportamentos inesperados
3. **Considere a profundidade da recurs√£o** para evitar estouro de pilha
4. **Use memoiza√ß√£o** para fun√ß√µes que recalculam os mesmos valores
5. **Considere alternativas iterativas** para casos onde a recurs√£o √© ineficiente
6. **Utilize recurs√£o em cauda** quando poss√≠vel, pois pode ser otimizada
7. **Documente claramente** o funcionamento da recurs√£o para facilitar a manuten√ß√£o

### üìù Exemplo Pr√°tico: Sistema de Arquivos

Vamos implementar uma fun√ß√£o recursiva para listar arquivos em um diret√≥rio e seus subdiret√≥rios.

```c
#include <stdio.h>
#include <dirent.h>
#include <string.h>
#include <sys/stat.h>

// Fun√ß√£o recursiva para listar arquivos em um diret√≥rio e subdiret√≥rios
void listar_arquivos(const char* caminho, int nivel) {
    DIR* dir;
    struct dirent* entrada;
    struct stat info;
    char caminho_completo[1024];
    
    // Abre o diret√≥rio
    dir = opendir(caminho);
    if (dir == NULL) {
        printf("N√£o foi poss√≠vel abrir o diret√≥rio: %s\n", caminho);
        return;
    }
    
    // Percorre as entradas do diret√≥rio
    while ((entrada = readdir(dir)) != NULL) {
        // Ignora os diret√≥rios "." e ".."
        if (strcmp(entrada->d_name, ".") == 0 || strcmp(entrada->d_name, "..") == 0) {
            continue;
        }
        
        // Constr√≥i o caminho completo
        snprintf(caminho_completo, sizeof(caminho_completo), "%s/%s", caminho, entrada->d_name);
        
        // Obt√©m informa√ß√µes sobre o arquivo
        if (stat(caminho_completo, &info) != 0) {
            printf("Erro ao obter informa√ß√µes: %s\n", caminho_completo);
            continue;
        }
        
        // Imprime indenta√ß√£o para mostrar a hierarquia
        for (int i = 0; i < nivel; i++) {
            printf("  ");
        }
        
        // Imprime o nome do arquivo/diret√≥rio
        printf("|-- %s\n", entrada->d_name);
        
        // Se for um diret√≥rio, chama recursivamente
        if (S_ISDIR(info.st_mode)) {
            listar_arquivos(caminho_completo, nivel + 1);
        }
    }
    
    closedir(dir);
}

int main() {
    const char* diretorio = ".";  // Diret√≥rio atual
    printf("Listando arquivos em: %s\n", diretorio);
    listar_arquivos(diretorio, 0);
    return 0;
}
```

**Observa√ß√£o**: Este c√≥digo funciona em sistemas Unix/Linux. Para Windows, seria necess√°rio usar as APIs espec√≠ficas do Windows.

### üßÆ Resumo

A recurs√£o √© uma t√©cnica poderosa na programa√ß√£o em C, especialmente √∫til para:

1. Problemas que podem ser divididos em subproblemas id√™nticos, por√©m menores
2. Algoritmos que seguem naturalmente uma abordagem recursiva, como Torres de Han√≥i
3. Manipula√ß√£o de estruturas de dados hier√°rquicas, como √°rvores e sistemas de arquivos

Apesar de suas vantagens em clareza e eleg√¢ncia, √© importante estar ciente das limita√ß√µes de desempenho e do risco de estouro de pilha.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Pr√≥s da Recurs√£o    ‚îÇ Contras da Recurs√£o                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ - C√≥digo elegante   ‚îÇ - Risco de estouro de pilha             ‚îÇ
‚îÇ - Mais leg√≠vel para ‚îÇ - Overhead de chamadas de fun√ß√£o        ‚îÇ
‚îÇ   certos problemas  ‚îÇ - Pode ser ineficiente (rec√°lculos)     ‚îÇ
‚îÇ - Natural para      ‚îÇ - Maior consumo de mem√≥ria              ‚îÇ
‚îÇ   estruturas        ‚îÇ - Mais dif√≠cil de depurar               ‚îÇ
‚îÇ   hier√°rquicas      ‚îÇ                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

[üîô Voltar ao √≠ndice principal](../README.md)

<img width=100% src="https://capsule-render.vercel.app/api?type=waving&color=A8B9CC&height=120&section=footer"/> 