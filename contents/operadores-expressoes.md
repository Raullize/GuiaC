<img width=100% src="https://capsule-render.vercel.app/api?type=waving&color=A8B9CC&height=120&section=header"/>

# ‚ûó Operadores e Express√µes

## üìã Trabalhando com Operadores em C

Os operadores s√£o s√≠mbolos especiais que realizam opera√ß√µes espec√≠ficas em um ou mais operandos. Uma express√£o √© uma combina√ß√£o de operadores e operandos que s√£o avaliados para produzir um resultado.

### üìä Operadores Aritm√©ticos

Operadores aritm√©ticos s√£o usados para realizar opera√ß√µes matem√°ticas b√°sicas:

| Operador | Descri√ß√£o            | Exemplo     | Resultado |
|----------|----------------------|-------------|-----------|
| `+`      | Adi√ß√£o               | `5 + 3`     | `8`       |
| `-`      | Subtra√ß√£o            | `5 - 3`     | `2`       |
| `*`      | Multiplica√ß√£o        | `5 * 3`     | `15`      |
| `/`      | Divis√£o              | `5 / 3`     | `1`       |
| `%`      | M√≥dulo (resto)       | `5 % 3`     | `2`       |

**Observa√ß√£o**: A divis√£o entre inteiros em C resulta em um inteiro (truncado), como mostrado no exemplo de `5 / 3` que resulta em `1`.

```c
#include <stdio.h>

int main() {
    int a = 10, b = 3;
    
    printf("Adi√ß√£o: %d + %d = %d\n", a, b, a + b);        // 13
    printf("Subtra√ß√£o: %d - %d = %d\n", a, b, a - b);     // 7
    printf("Multiplica√ß√£o: %d * %d = %d\n", a, b, a * b); // 30
    printf("Divis√£o: %d / %d = %d\n", a, b, a / b);       // 3
    printf("M√≥dulo: %d %% %d = %d\n", a, b, a % b);       // 1
    
    // Exemplo com ponto flutuante
    float x = 10.0f, y = 3.0f;
    printf("Divis√£o real: %.1f / %.1f = %.2f\n", x, y, x / y);  // 3.33
    
    return 0;
}
```

### üëÜ Operadores de Incremento e Decremento

C fornece operadores especiais para incrementar ou decrementar o valor de uma vari√°vel em 1:

| Operador | Descri√ß√£o             | Exemplo       | Equivalente a |
|----------|----------------------|---------------|---------------|
| `++`     | Incremento           | `i++` ou `++i`| `i = i + 1`   |
| `--`     | Decremento           | `i--` ou `--i`| `i = i - 1`   |

Existem duas formas para cada um:
- **Pr√©-incremento/decremento**: `++i`, `--i` (incrementa/decrementa antes de usar o valor)
- **P√≥s-incremento/decremento**: `i++`, `i--` (incrementa/decrementa ap√≥s usar o valor)

```c
#include <stdio.h>

int main() {
    int a = 5, b = 5;
    int result;
    
    // P√≥s-incremento: o valor original √© usado na express√£o, depois incrementado
    result = a++;
    printf("result = a++ resulta em result=%d, a=%d\n", result, a);  // result=5, a=6
    
    // Pr√©-incremento: o valor √© incrementado primeiro, depois usado na express√£o
    result = ++b;
    printf("result = ++b resulta em result=%d, b=%d\n", result, b);  // result=6, b=6
    
    return 0;
}
```

### üîÑ Operadores de Atribui√ß√£o

Os operadores de atribui√ß√£o s√£o usados para atribuir valores a vari√°veis:

| Operador | Descri√ß√£o                      | Exemplo     | Equivalente a  |
|----------|--------------------------------|-------------|----------------|
| `=`      | Atribui√ß√£o simples             | `a = b`     | `a = b`        |
| `+=`     | Atribui√ß√£o com adi√ß√£o          | `a += b`    | `a = a + b`    |
| `-=`     | Atribui√ß√£o com subtra√ß√£o       | `a -= b`    | `a = a - b`    |
| `*=`     | Atribui√ß√£o com multiplica√ß√£o   | `a *= b`    | `a = a * b`    |
| `/=`     | Atribui√ß√£o com divis√£o         | `a /= b`    | `a = a / b`    |
| `%=`     | Atribui√ß√£o com m√≥dulo          | `a %= b`    | `a = a % b`    |
| `<<=`    | Atribui√ß√£o com shift left      | `a <<= b`   | `a = a << b`   |
| `>>=`    | Atribui√ß√£o com shift right     | `a >>= b`   | `a = a >> b`   |
| `&=`     | Atribui√ß√£o com AND bit a bit   | `a &= b`    | `a = a & b`    |
| `^=`     | Atribui√ß√£o com XOR bit a bit   | `a ^= b`    | `a = a ^ b`    |
| `|=`     | Atribui√ß√£o com OR bit a bit    | `a |= b`    | `a = a | b`    |

```c
#include <stdio.h>

int main() {
    int a = 10;
    
    printf("Valor inicial: a = %d\n", a);         // 10
    
    a += 5;  // Equivalente a: a = a + 5
    printf("Ap√≥s a += 5: a = %d\n", a);           // 15
    
    a -= 3;  // Equivalente a: a = a - 3
    printf("Ap√≥s a -= 3: a = %d\n", a);           // 12
    
    a *= 2;  // Equivalente a: a = a * 2
    printf("Ap√≥s a *= 2: a = %d\n", a);           // 24
    
    a /= 3;  // Equivalente a: a = a / 3
    printf("Ap√≥s a /= 3: a = %d\n", a);           // 8
    
    a %= 5;  // Equivalente a: a = a % 5
    printf("Ap√≥s a %%= 5: a = %d\n", a);          // 3
    
    return 0;
}
```

### üìè Operadores de Compara√ß√£o (Relacionais)

Operadores de compara√ß√£o s√£o usados para comparar dois valores:

| Operador | Descri√ß√£o               | Exemplo  | Resultado se `a=5, b=3` |
|----------|-------------------------|----------|-----------------------|
| `==`     | Igual a                 | `a == b` | `0` (falso)           |
| `!=`     | Diferente de            | `a != b` | `1` (verdadeiro)      |
| `>`      | Maior que               | `a > b`  | `1` (verdadeiro)      |
| `<`      | Menor que               | `a < b`  | `0` (falso)           |
| `>=`     | Maior ou igual a        | `a >= b` | `1` (verdadeiro)      |
| `<=`     | Menor ou igual a        | `a <= b` | `0` (falso)           |

Em C, o resultado de uma express√£o de compara√ß√£o √© `1` se for verdadeira e `0` se for falsa.

```c
#include <stdio.h>

int main() {
    int a = 5, b = 3;
    
    printf("%d == %d: %d\n", a, b, a == b);  // 0 (falso)
    printf("%d != %d: %d\n", a, b, a != b);  // 1 (verdadeiro)
    printf("%d > %d: %d\n", a, b, a > b);    // 1 (verdadeiro)
    printf("%d < %d: %d\n", a, b, a < b);    // 0 (falso)
    printf("%d >= %d: %d\n", a, b, a >= b);  // 1 (verdadeiro)
    printf("%d <= %d: %d\n", a, b, a <= b);  // 0 (falso)
    
    return 0;
}
```

### üî£ Operadores L√≥gicos

Operadores l√≥gicos s√£o usados para combinar express√µes condicionais:

| Operador | Descri√ß√£o                  | Exemplo      | Resultado se `a=1, b=0` |
|----------|----------------------------|--------------|------------------------|
| `&&`     | AND l√≥gico (E)             | `a && b`     | `0` (falso)            |
| `||`     | OR l√≥gico (OU)             | `a || b`     | `1` (verdadeiro)       |
| `!`      | NOT l√≥gico (N√ÉO)           | `!a`         | `0` (falso)            |

Em C, qualquer valor diferente de zero √© considerado verdadeiro, e zero √© considerado falso.

```c
#include <stdio.h>

int main() {
    int a = 1;  // verdadeiro
    int b = 0;  // falso
    
    // AND l√≥gico (&&) - verdadeiro somente se ambos operandos forem verdadeiros
    printf("%d && %d = %d\n", a, b, a && b);  // 0 (falso)
    
    // OR l√≥gico (||) - verdadeiro se pelo menos um operando for verdadeiro
    printf("%d || %d = %d\n", a, b, a || b);  // 1 (verdadeiro)
    
    // NOT l√≥gico (!) - inverte o valor l√≥gico
    printf("!%d = %d\n", a, !a);  // 0 (falso)
    printf("!%d = %d\n", b, !b);  // 1 (verdadeiro)
    
    // Express√µes compostas
    int x = 5, y = 10, z = 15;
    int resultado = (x < y) && (y < z);
    printf("(x < y) && (y < z) = %d\n", resultado);  // 1 (verdadeiro)
    
    return 0;
}
```

### üßÆ Operadores Bit a Bit (Bitwise)

Operadores bit a bit operam nos bits individuais dos operandos:

| Operador | Descri√ß√£o                | Exemplo   | Resultado (em bin√°rio) se `a=5 (101), b=3 (011)` |
|----------|--------------------------|-----------|------------------------------------------------|
| `&`      | AND bit a bit            | `a & b`   | `1 (001)`                                      |
| `|`      | OR bit a bit             | `a | b`   | `7 (111)`                                      |
| `^`      | XOR bit a bit            | `a ^ b`   | `6 (110)`                                      |
| `~`      | NOT bit a bit (complemento) | `~a`   | `-6 (complemento de 2)`                        |
| `<<`     | Shift left               | `a << 1`  | `10 (1010)`                                    |
| `>>`     | Shift right              | `a >> 1`  | `2 (010)`                                      |

```c
#include <stdio.h>

int main() {
    unsigned char a = 5;  // 00000101 em bin√°rio
    unsigned char b = 3;  // 00000011 em bin√°rio
    
    printf("a = %d (bin√°rio: %08b)\n", a, a);  // a = 5
    printf("b = %d (bin√°rio: %08b)\n", b, b);  // b = 3
    
    // AND bit a bit: bits s√£o 1 somente se ambos bits correspondentes forem 1
    printf("a & b = %d (bin√°rio: %08b)\n", a & b, a & b);  // 1 (00000001)
    
    // OR bit a bit: bits s√£o 1 se pelo menos um dos bits correspondentes for 1
    printf("a | b = %d (bin√°rio: %08b)\n", a | b, a | b);  // 7 (00000111)
    
    // XOR bit a bit: bits s√£o 1 se os bits correspondentes forem diferentes
    printf("a ^ b = %d (bin√°rio: %08b)\n", a ^ b, a ^ b);  // 6 (00000110)
    
    // NOT bit a bit (complemento): inverte todos os bits
    printf("~a = %d (bin√°rio: %08b)\n", (unsigned char)~a, (unsigned char)~a);  // 250 (11111010)
    
    // Shift left: desloca bits para a esquerda (multiplica por 2^n)
    printf("a << 1 = %d (bin√°rio: %08b)\n", a << 1, a << 1);  // 10 (00001010)
    
    // Shift right: desloca bits para a direita (divide por 2^n)
    printf("a >> 1 = %d (bin√°rio: %08b)\n", a >> 1, a >> 1);  // 2 (00000010)
    
    return 0;
}
```

**Observa√ß√£o**: O exemplo acima usa o formato de impress√£o `%08b`, que n√£o √© padr√£o em C. Na pr√°tica, voc√™ precisaria de uma fun√ß√£o auxiliar para imprimir o valor em formato bin√°rio.

### üîç Operadores de Tamanho e Endere√ßo

| Operador | Descri√ß√£o                     | Exemplo     | Resultado                         |
|----------|-------------------------------|-------------|-----------------------------------|
| `sizeof` | Tamanho em bytes              | `sizeof(int)` | `4` (depende da plataforma)    |
| `&`      | Operador de endere√ßo          | `&a`       | Endere√ßo de mem√≥ria da vari√°vel a |
| `*`      | Operador de desreferencia√ß√£o  | `*ptr`     | Valor no endere√ßo apontado por ptr|

```c
#include <stdio.h>

int main() {
    int a = 10;
    int *ptr = &a;  // ptr armazena o endere√ßo de a
    
    printf("Valor de a: %d\n", a);                     // 10
    printf("Endere√ßo de a: %p\n", (void*)&a);          // 0x...
    printf("Valor de ptr (endere√ßo de a): %p\n", (void*)ptr);  // 0x...
    printf("Valor apontado por ptr (*ptr): %d\n", *ptr);       // 10
    
    printf("Tamanho de int: %zu bytes\n", sizeof(int));        // 4 (tipicamente)
    printf("Tamanho de float: %zu bytes\n", sizeof(float));    // 4 (tipicamente)
    printf("Tamanho de char: %zu bytes\n", sizeof(char));      // 1
    printf("Tamanho de double: %zu bytes\n", sizeof(double));  // 8 (tipicamente)
    printf("Tamanho da vari√°vel a: %zu bytes\n", sizeof(a));   // 4 (tipicamente)
    
    return 0;
}
```

### üîÑ Operador Condicional Tern√°rio

O operador tern√°rio `? :` √© o √∫nico operador em C que aceita tr√™s operandos:

```
condi√ß√£o ? express√£o1 : express√£o2
```

Se a condi√ß√£o for verdadeira, a express√£o1 √© avaliada e se torna o resultado; caso contr√°rio, a express√£o2 √© avaliada e se torna o resultado.

```c
#include <stdio.h>

int main() {
    int a = 10;
    int b = 20;
    
    // Usando operador tern√°rio para encontrar o maior valor
    int max = (a > b) ? a : b;
    printf("O maior valor entre %d e %d √©: %d\n", a, b, max);  // 20
    
    // Equivalente usando if-else
    int max2;
    if (a > b) {
        max2 = a;
    } else {
        max2 = b;
    }
    printf("O maior valor entre %d e %d √©: %d\n", a, b, max2);  // 20
    
    // Exemplo com express√µes mais complexas
    int idade = 18;
    printf("Voc√™ %s beber legalmente nos EUA.\n", 
           (idade >= 21) ? "pode" : "n√£o pode");  // n√£o pode
    
    return 0;
}
```

### üîÑ Operador V√≠rgula

O operador v√≠rgula (`,`) permite avaliar m√∫ltiplas express√µes onde apenas uma √© esperada. As express√µes s√£o avaliadas da esquerda para a direita, e o valor da express√£o mais √† direita se torna o valor da express√£o composta.

```c
#include <stdio.h>

int main() {
    int a, b, c;
    
    // A v√≠rgula aqui √© apenas um separador, n√£o o operador v√≠rgula
    
    // Usando o operador v√≠rgula em uma express√£o for
    for (a = 1, b = 10; a <= 5; a++, b += 10) {
        printf("a = %d, b = %d\n", a, b);
    }
    
    // Usando o operador v√≠rgula em uma atribui√ß√£o
    c = (a = 3, b = a + 2, a + b);
    printf("c = %d (a = %d, b = %d)\n", c, a, b);  // c = 8, a = 3, b = 5
    
    return 0;
}
```

### üìä Preced√™ncia de Operadores

A preced√™ncia dos operadores determina a ordem na qual as opera√ß√µes s√£o realizadas em uma express√£o. Operadores com maior preced√™ncia s√£o avaliados antes dos operadores com menor preced√™ncia.

| Preced√™ncia | Operador                          | Associatividade |
|-------------|------------------------------------|----------------|
| Maior       | `()` `[]` `->` `.`                | Esquerda para direita |
|             | `!` `~` `++` `--` `+` `-` (un√°rio) `&` (endere√ßo) `*` (ponteiro) `sizeof` | Direita para esquerda |
|             | `*` `/` `%`                       | Esquerda para direita |
|             | `+` `-` (bin√°rio)                 | Esquerda para direita |
|             | `<<` `>>`                         | Esquerda para direita |
|             | `<` `<=` `>` `>=`                 | Esquerda para direita |
|             | `==` `!=`                         | Esquerda para direita |
|             | `&` (bit a bit AND)               | Esquerda para direita |
|             | `^` (bit a bit XOR)               | Esquerda para direita |
|             | `|` (bit a bit OR)                | Esquerda para direita |
|             | `&&` (l√≥gico AND)                 | Esquerda para direita |
|             | `||` (l√≥gico OR)                  | Esquerda para direita |
|             | `?:` (tern√°rio)                   | Direita para esquerda |
|             | `=` `+=` `-=` `*=` `/=` `%=` `&=` `^=` `|=` `<<=` `>>=` | Direita para esquerda |
| Menor       | `,` (v√≠rgula)                     | Esquerda para direita |

```c
#include <stdio.h>

int main() {
    int a = 5, b = 3, c = 8;
    int result;
    
    // Demonstra√ß√£o de preced√™ncia
    result = a + b * c;        // b * c √© calculado primeiro, depois √© adicionado a
    printf("a + b * c = %d\n", result);  // 5 + (3 * 8) = 5 + 24 = 29
    
    result = (a + b) * c;      // a + b √© calculado primeiro (devido aos par√™nteses), depois multiplicado por c
    printf("(a + b) * c = %d\n", result);  // (5 + 3) * 8 = 8 * 8 = 64
    
    // Mais exemplos
    result = a + b - c;       // Da esquerda para a direita devido √† mesma preced√™ncia
    printf("a + b - c = %d\n", result);  // (5 + 3) - 8 = 8 - 8 = 0
    
    result = a * b + c / 2;   // Primeiro a * b e c / 2, depois a soma
    printf("a * b + c / 2 = %d\n", result);  // (5 * 3) + (8 / 2) = 15 + 4 = 19
    
    // Combina√ß√£o de operadores l√≥gicos e relacionais
    int d = 1;
    result = a > b && c > d;  // Primeiro as compara√ß√µes, depois o AND l√≥gico
    printf("a > b && c > d = %d\n", result);  // (5 > 3) && (8 > 1) = 1 && 1 = 1
    
    return 0;
}
```

### üß™ Convers√£o de Tipos (Casting)

Em C, existem dois tipos de convers√£o de tipos:

1. **Convers√£o Impl√≠cita**: Ocorre automaticamente quando um valor √© usado em um contexto que requer outro tipo.
2. **Convers√£o Expl√≠cita (Casting)**: √â feita manualmente pelo programador utilizando o operador de casting.

```c
#include <stdio.h>

int main() {
    int i = 10;
    float f = 3.5;
    
    // Convers√£o impl√≠cita
    float resultado1 = i + f;    // i √© convertido para float antes da adi√ß√£o
    printf("%d + %.1f = %.1f\n", i, f, resultado1);  // 10 + 3.5 = 13.5
    
    // Divis√£o entre inteiros
    int a = 5, b = 2;
    float resultado2 = a / b;    // a divis√£o ocorre entre inteiros, resultando em 2
    printf("%d / %d = %.1f\n", a, b, resultado2);  // 5 / 2 = 2.0
    
    // Convers√£o expl√≠cita (cast)
    float resultado3 = (float)a / b;  // a √© explicitamente convertido para float antes da divis√£o
    printf("(float)%d / %d = %.1f\n", a, b, resultado3);  // (float)5 / 2 = 2.5
    
    // Outros exemplos de cast
    int x = 7;
    int y = 2;
    double resultado4 = (double)x / y;
    printf("(double)%d / %d = %.1f\n", x, y, resultado4);  // (double)7 / 2 = 3.5
    
    // Truncamento ao converter float para int
    float valor = 9.7;
    int valorInt = (int)valor;  // O valor √© truncado, n√£o arredondado
    printf("(int)%.1f = %d\n", valor, valorInt);  // (int)9.7 = 9
    
    return 0;
}
```

### ‚öôÔ∏è Express√µes de Avalia√ß√£o

Uma express√£o √© uma sequ√™ncia de operadores e operandos que especifica um c√°lculo. Express√µes podem ser:

1. **Aritm√©ticas**: Resultam em um valor num√©rico (`a + b * c`)
2. **Relacionais**: Resultam em verdadeiro ou falso (`a > b`)
3. **L√≥gicas**: Combinam express√µes relacionais (`(a > b) && (c < d)`)
4. **De atribui√ß√£o**: Atribuem valores a vari√°veis (`a = b + c`)

```c
#include <stdio.h>

int main() {
    int a = 5, b = 3, c = 10;
    int resultado;
    
    // Express√£o aritm√©tica
    resultado = a + b * c / 2 - 1;
    printf("a + b * c / 2 - 1 = %d\n", resultado);  // 5 + 3 * 10 / 2 - 1 = 5 + 15 - 1 = 19
    
    // Express√£o relacional
    int ehMaior = a > b;
    printf("a > b = %d\n", ehMaior);  // 1 (verdadeiro)
    
    // Express√£o l√≥gica
    int logico = (a > b) && (c > a);
    printf("(a > b) && (c > a) = %d\n", logico);  // 1 (verdadeiro)
    
    // Express√µes de atribui√ß√£o
    a += 2;  // a = a + 2
    printf("Ap√≥s a += 2, a = %d\n", a);  // 7
    
    // Express√£o com efeitos colaterais
    int d = 1;
    resultado = a + (d += 2);  // d √© incrementado, depois somado a 'a'
    printf("a + (d += 2) = %d, d = %d\n", resultado, d);  // 10, d = 3
    
    return 0;
}
```

### üö´ Erros Comuns com Operadores

1. **Confundir `=` (atribui√ß√£o) com `==` (compara√ß√£o)**:
   ```c
   if (a = 5) {  // Atribui 5 a 'a' e verifica se √© n√£o-zero (sempre verdadeiro)
       // C√≥digo executado sempre
   }
   // Correto: if (a == 5)
   ```

2. **Divis√£o inteira inesperada**:
   ```c
   float resultado = 5 / 2;       // Resultado √© 2.0, n√£o 2.5
   // Correto: float resultado = 5.0 / 2 ou (float)5 / 2
   ```

3. **Avalia√ß√£o de curto-circuito mal interpretada**:
   ```c
   if (ptr != NULL && ptr->valor > 10) {
       // C√≥digo seguro: se ptr for NULL, a segunda parte n√£o √© avaliada
   }
   
   if (ptr->valor > 10 && ptr != NULL) {
       // PERIGO: se ptr for NULL, a primeira verifica√ß√£o causar√° erro
   }
   ```

4. **Preced√™ncia de operadores n√£o considerada**:
   ```c
   int resultado = a + b * c;      // Pode n√£o fazer o que voc√™ espera
   // Se a ordem desejada for diferente: int resultado = (a + b) * c;
   ```

5. **Efeitos colaterais de incremento/decremento**:
   ```c
   int a = 5;
   printf("%d %d\n", a++, a++);  // Comportamento indefinido!
   ```

### ‚ö° Resumo dos Operadores em C

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Categoria                        ‚îÇ Operadores            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Aritm√©ticos                      ‚îÇ + - * / %            ‚îÇ
‚îÇ Incremento/Decremento            ‚îÇ ++ --                ‚îÇ
‚îÇ Relacionais                      ‚îÇ == != > < >= <=      ‚îÇ
‚îÇ L√≥gicos                          ‚îÇ && || !              ‚îÇ
‚îÇ Bit a bit                        ‚îÇ & | ^ ~ << >>        ‚îÇ
‚îÇ Atribui√ß√£o                       ‚îÇ = += -= *= /= %=     ‚îÇ
‚îÇ                                  ‚îÇ &= |= ^= <<= >>=     ‚îÇ
‚îÇ Tamanho e Endere√ßo               ‚îÇ sizeof & *           ‚îÇ
‚îÇ Condicional                      ‚îÇ ?:                   ‚îÇ
‚îÇ V√≠rgula                          ‚îÇ ,                    ‚îÇ
‚îÇ Acesso a Membros de Estrutura    ‚îÇ . ->                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

[üîô Voltar ao √≠ndice principal](../README.md)

<img width=100% src="https://capsule-render.vercel.app/api?type=waving&color=A8B9CC&height=120&section=footer"/> 